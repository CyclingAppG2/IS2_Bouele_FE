import { Inject, Injectable, InjectionToken, Injector, NgModule } from '@angular/core';
import { Router } from '@angular/router';
import { first as first$1 } from 'rxjs/operator/first';
import { switchMap as switchMap$1 } from 'rxjs/operator/switchMap';
import { map as map$1 } from 'rxjs/operator/map';
import { _catch as _catch$1 } from 'rxjs/operator/catch';
import { _throw as _throw$1 } from 'rxjs/observable/throw';
import { HTTP_INTERCEPTORS, HttpClient } from '@angular/common/http';
import { Subject as Subject$1 } from 'rxjs/Subject';
/**
 * Essential service for authentication
 * @export
 * @interface AuthService
 */
var AuthService = (function () {
    function AuthService() {
    }
    return AuthService;
}());
function first$2(obs) {
    return first$1.call(obs);
}
function switchMap$2(obs, project) {
    return switchMap$1.call(obs, project);
}
function map$2(obs, project) {
    return map$1.call(obs, project);
}
function _catch$2(obs, selector) {
    return _catch$1.call(obs, selector);
}
var AUTH_SERVICE = new InjectionToken('AUTH_SERVICE');
var PUBLIC_FALLBACK_PAGE_URI = new InjectionToken('PUBLIC_FALLBACK_PAGE_URI');
var PROTECTED_FALLBACK_PAGE_URI = new InjectionToken('PROTECTED_FALLBACK_PAGE_URI');
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
};
/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 *
 * usage: { path: 'test', component: TestComponent, canActivate: [ PublicGuard ] }
 *
 * @export
 *
 * @class PublicGuard
 *
 * @implements {CanActivate}
 * @implements {CanActivateChild}
 */
var PublicGuard = (function () {
    function PublicGuard(authService, protectedFallbackPageUri, router$$1) {
        this.authService = authService;
        this.protectedFallbackPageUri = protectedFallbackPageUri;
        this.router = router$$1;
    }
    /**
     * CanActivate handler
     *
     * @param {ActivatedRouteSnapshot} _route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    PublicGuard.prototype.canActivate = function (_route, state) {
        var _this = this;
        return map$2(this.authService.isAuthorized(), function (isAuthorized) {
            if (isAuthorized && !_this.isProtectedPage(state)) {
                _this.navigate(_this.protectedFallbackPageUri);
                return false;
            }
            return true;
        });
    };
    /**
     * CanActivateChild handler
     *
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    PublicGuard.prototype.canActivateChild = function (route, state) {
        return this.canActivate(route, state);
    };
    /**
     * Check, if current page is protected fallback page
     *
     * @private
     *
     * @param {RouterStateSnapshot} state
     *
     * @returns {boolean}
     */
    PublicGuard.prototype.isProtectedPage = function (state) {
        return state.url === this.protectedFallbackPageUri;
    };
    /**
     * Navigate away from the app / path
     *
     * @private
     * @param {string} url
     */
    PublicGuard.prototype.navigate = function (url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    };
    return PublicGuard;
}());
PublicGuard = __decorate([
    Injectable(),
    __param(0, Inject(AUTH_SERVICE)),
    __param(1, Inject(PROTECTED_FALLBACK_PAGE_URI)),
    __metadata("design:paramtypes", [AuthService, String, Router])
], PublicGuard);
var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
};
/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 *
 * usage: { path: 'test', component: TestComponent, canActivate: [ AuthGuard ] }
 *
 * @export
 *
 * @class ProtectedGuard
 *
 * @implements {CanActivate}
 * @implements {CanActivateChild}
 */
var ProtectedGuard = (function () {
    function ProtectedGuard(authService, publicFallbackPageUri, router$$1) {
        this.authService = authService;
        this.publicFallbackPageUri = publicFallbackPageUri;
        this.router = router$$1;
    }
    /**
     * CanActivate handler
     *
     * @param {ActivatedRouteSnapshot} _route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    ProtectedGuard.prototype.canActivate = function (_route, state) {
        var _this = this;
        return map$2(this.authService.isAuthorized(), function (isAuthorized) {
            if (!isAuthorized && !_this.isPublicPage(state)) {
                _this.navigate(_this.publicFallbackPageUri);
                return false;
            }
            return true;
        });
    };
    /**
     * CanActivateChild handler
     *
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    ProtectedGuard.prototype.canActivateChild = function (route, state) {
        return this.canActivate(route, state);
    };
    /**
     * Check, if current page is public fallback page
     *
     * @private
     *
     * @param {RouterStateSnapshot} state
     *
     * @returns {boolean}
     */
    ProtectedGuard.prototype.isPublicPage = function (state) {
        return state.url === this.publicFallbackPageUri;
    };
    /**
     * Navigate away from the app / path
     *
     * @private
     * @param {string} url
     */
    ProtectedGuard.prototype.navigate = function (url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    };
    return ProtectedGuard;
}());
ProtectedGuard = __decorate$1([
    Injectable(),
    __param$1(0, Inject(AUTH_SERVICE)),
    __param$1(1, Inject(PUBLIC_FALLBACK_PAGE_URI)),
    __metadata$1("design:paramtypes", [AuthService, String, Router])
], ProtectedGuard);
var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
var AuthInterceptor = (function () {
    function AuthInterceptor(injector) {
        this.injector = injector;
        /**
         * Is refresh token is being executed
         *
         * @private
         *
         * @type {boolean}
         */
        this.refreshInProgress = false;
        /**
         * Notify all outstanding requests through this subject
         *
         * @private
         *
         * @type {Subject<boolean>}
         */
        this.refreshSubject = new Subject$1();
    }
    /**
     * Intercept an outgoing `HttpRequest`
     *
     * @param {HttpRequest<*>} req
     * @param {HttpHandler} delegate
     *
     * @returns {Observable<HttpEvent<*>>}
     */
    AuthInterceptor.prototype.intercept = function (req, delegate) {
        var authService = this.injector.get(AUTH_SERVICE);
        if (authService.verifyTokenRequest(req.url)) {
            return delegate.handle(req);
        }
        return this.processIntercept(req, delegate);
    };
    /**
     * Process all the requests via custom interceptors.
     *
     * @private
     *
     * @param {HttpRequest<*>} original
     * @param {HttpHandler} delegate
     *
     * @returns {Observable<HttpEvent<*>>}
     */
    AuthInterceptor.prototype.processIntercept = function (original, delegate) {
        var _this = this;
        var clone = original.clone();
        return _catch$2(switchMap$2(this.request(clone), function (req) { return delegate.handle(req); }), function (res) { return _this.responseError(clone, res); });
    };
    /**
     * Request interceptor. Delays request if refresh is in progress
     * otherwise adds token to the headers
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     *
     * @returns {Observable}
     */
    AuthInterceptor.prototype.request = function (req) {
        if (this.refreshInProgress) {
            return this.delayRequest(req);
        }
        return this.addToken(req);
    };
    /**
     * Failed request interceptor, check if it has to be processed with refresh
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     * @param {HttpErrorResponse} res
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    AuthInterceptor.prototype.responseError = function (req, res) {
        var _this = this;
        var authService = this.injector.get(AUTH_SERVICE);
        var refreshShouldHappen = authService.refreshShouldHappen(res);
        if (refreshShouldHappen && !this.refreshInProgress) {
            this.refreshInProgress = true;
            authService
                .refreshToken()
                .subscribe(function () {
                _this.refreshInProgress = false;
                _this.refreshSubject.next(true);
            }, function () {
                _this.refreshInProgress = false;
                _this.refreshSubject.next(false);
            });
        }
        if (refreshShouldHappen && this.refreshInProgress) {
            return this.delayRequest(req, res);
        }
        return _throw$1(res);
    };
    /**
     * Add access token to headers or the request
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    AuthInterceptor.prototype.addToken = function (req) {
        var authService = this.injector.get(AUTH_SERVICE);
        return first$2(map$2(authService.getAccessToken(), function (token) {
            if (token) {
                var headers = void 0;
                if (typeof authService.getHeaders === 'function') {
                    headers = authService.getHeaders(token);
                }
                else {
                    headers = { Authorization: "Bearer " + token };
                }
                return req.clone({
                    setHeaders: headers
                });
            }
            return req;
        }));
    };
    /**
     * Delay request, by subscribing on refresh event, once it finished, process it
     * otherwise throw error
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     * @param {HttpErrorResponse} [res]
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    AuthInterceptor.prototype.delayRequest = function (req, res) {
        var http$$1 = this.injector.get(HttpClient);
        return switchMap$2(first$2(this.refreshSubject), function (status) {
            if (status) {
                return http$$1.request(req);
            }
            return _throw$1(res || req);
        });
    };
    return AuthInterceptor;
}());
AuthInterceptor = __decorate$3([
    Injectable(),
    __metadata$2("design:paramtypes", [Injector])
], AuthInterceptor);
var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AuthModule = (function () {
    function AuthModule() {
    }
    return AuthModule;
}());
AuthModule = __decorate$2([
    NgModule({
        providers: [
            PublicGuard,
            ProtectedGuard,
            AuthInterceptor,
            {
                provide: HTTP_INTERCEPTORS,
                useClass: AuthInterceptor,
                multi: true,
            }
        ]
    })
], AuthModule);
/**
 * Generated bundle index. Do not edit.
 */
export { AuthInterceptor as ɵa, AuthService, PublicGuard, ProtectedGuard, AUTH_SERVICE, PUBLIC_FALLBACK_PAGE_URI, PROTECTED_FALLBACK_PAGE_URI, AuthModule };
//# sourceMappingURL=ngx-auth.es5.js.map
