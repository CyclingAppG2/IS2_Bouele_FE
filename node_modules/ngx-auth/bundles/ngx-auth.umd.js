(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/router'), require('rxjs/operator/first'), require('rxjs/operator/switchMap'), require('rxjs/operator/map'), require('rxjs/operator/catch'), require('rxjs/observable/throw'), require('@angular/common/http'), require('rxjs/Subject')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/router', 'rxjs/operator/first', 'rxjs/operator/switchMap', 'rxjs/operator/map', 'rxjs/operator/catch', 'rxjs/observable/throw', '@angular/common/http', 'rxjs/Subject'], factory) :
	(factory((global['ngx-auth'] = {}),global.ng.core,global.ng.router,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable,global.ng.common.http,global.Rx));
}(this, (function (exports,core,router,first,switchMap,map,_catch,_throw,http,Subject) { 'use strict';

/**
 * Essential service for authentication
 * @export
 * @interface AuthService
 */
var AuthService = (function () {
    function AuthService() {
    }
    return AuthService;
}());
function first$2(obs) {
    return first.first.call(obs);
}
function switchMap$2(obs, project) {
    return switchMap.switchMap.call(obs, project);
}
function map$2(obs, project) {
    return map.map.call(obs, project);
}
function _catch$2(obs, selector) {
    return _catch._catch.call(obs, selector);
}
var AUTH_SERVICE = new core.InjectionToken('AUTH_SERVICE');
var PUBLIC_FALLBACK_PAGE_URI = new core.InjectionToken('PUBLIC_FALLBACK_PAGE_URI');
var PROTECTED_FALLBACK_PAGE_URI = new core.InjectionToken('PROTECTED_FALLBACK_PAGE_URI');
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
};
/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 *
 * usage: { path: 'test', component: TestComponent, canActivate: [ PublicGuard ] }
 *
 * @export
 *
 * @class PublicGuard
 *
 * @implements {CanActivate}
 * @implements {CanActivateChild}
 */
exports.PublicGuard = (function () {
    function PublicGuard(authService, protectedFallbackPageUri, router$$1) {
        this.authService = authService;
        this.protectedFallbackPageUri = protectedFallbackPageUri;
        this.router = router$$1;
    }
    /**
     * CanActivate handler
     *
     * @param {ActivatedRouteSnapshot} _route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    PublicGuard.prototype.canActivate = function (_route, state) {
        var _this = this;
        return map$2(this.authService.isAuthorized(), function (isAuthorized) {
            if (isAuthorized && !_this.isProtectedPage(state)) {
                _this.navigate(_this.protectedFallbackPageUri);
                return false;
            }
            return true;
        });
    };
    /**
     * CanActivateChild handler
     *
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    PublicGuard.prototype.canActivateChild = function (route, state) {
        return this.canActivate(route, state);
    };
    /**
     * Check, if current page is protected fallback page
     *
     * @private
     *
     * @param {RouterStateSnapshot} state
     *
     * @returns {boolean}
     */
    PublicGuard.prototype.isProtectedPage = function (state) {
        return state.url === this.protectedFallbackPageUri;
    };
    /**
     * Navigate away from the app / path
     *
     * @private
     * @param {string} url
     */
    PublicGuard.prototype.navigate = function (url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    };
    return PublicGuard;
}());
exports.PublicGuard = __decorate([
    core.Injectable(),
    __param(0, core.Inject(AUTH_SERVICE)),
    __param(1, core.Inject(PROTECTED_FALLBACK_PAGE_URI)),
    __metadata("design:paramtypes", [AuthService, String, router.Router])
], exports.PublicGuard);
var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); };
};
/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 *
 * usage: { path: 'test', component: TestComponent, canActivate: [ AuthGuard ] }
 *
 * @export
 *
 * @class ProtectedGuard
 *
 * @implements {CanActivate}
 * @implements {CanActivateChild}
 */
exports.ProtectedGuard = (function () {
    function ProtectedGuard(authService, publicFallbackPageUri, router$$1) {
        this.authService = authService;
        this.publicFallbackPageUri = publicFallbackPageUri;
        this.router = router$$1;
    }
    /**
     * CanActivate handler
     *
     * @param {ActivatedRouteSnapshot} _route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    ProtectedGuard.prototype.canActivate = function (_route, state) {
        var _this = this;
        return map$2(this.authService.isAuthorized(), function (isAuthorized) {
            if (!isAuthorized && !_this.isPublicPage(state)) {
                _this.navigate(_this.publicFallbackPageUri);
                return false;
            }
            return true;
        });
    };
    /**
     * CanActivateChild handler
     *
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    ProtectedGuard.prototype.canActivateChild = function (route, state) {
        return this.canActivate(route, state);
    };
    /**
     * Check, if current page is public fallback page
     *
     * @private
     *
     * @param {RouterStateSnapshot} state
     *
     * @returns {boolean}
     */
    ProtectedGuard.prototype.isPublicPage = function (state) {
        return state.url === this.publicFallbackPageUri;
    };
    /**
     * Navigate away from the app / path
     *
     * @private
     * @param {string} url
     */
    ProtectedGuard.prototype.navigate = function (url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    };
    return ProtectedGuard;
}());
exports.ProtectedGuard = __decorate$1([
    core.Injectable(),
    __param$1(0, core.Inject(AUTH_SERVICE)),
    __param$1(1, core.Inject(PUBLIC_FALLBACK_PAGE_URI)),
    __metadata$1("design:paramtypes", [AuthService, String, router.Router])
], exports.ProtectedGuard);
var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
exports.ɵa = (function () {
    function AuthInterceptor(injector) {
        this.injector = injector;
        /**
         * Is refresh token is being executed
         *
         * @private
         *
         * @type {boolean}
         */
        this.refreshInProgress = false;
        /**
         * Notify all outstanding requests through this subject
         *
         * @private
         *
         * @type {Subject<boolean>}
         */
        this.refreshSubject = new Subject.Subject();
    }
    /**
     * Intercept an outgoing `HttpRequest`
     *
     * @param {HttpRequest<*>} req
     * @param {HttpHandler} delegate
     *
     * @returns {Observable<HttpEvent<*>>}
     */
    AuthInterceptor.prototype.intercept = function (req, delegate) {
        var authService = this.injector.get(AUTH_SERVICE);
        if (authService.verifyTokenRequest(req.url)) {
            return delegate.handle(req);
        }
        return this.processIntercept(req, delegate);
    };
    /**
     * Process all the requests via custom interceptors.
     *
     * @private
     *
     * @param {HttpRequest<*>} original
     * @param {HttpHandler} delegate
     *
     * @returns {Observable<HttpEvent<*>>}
     */
    AuthInterceptor.prototype.processIntercept = function (original, delegate) {
        var _this = this;
        var clone = original.clone();
        return _catch$2(switchMap$2(this.request(clone), function (req) { return delegate.handle(req); }), function (res) { return _this.responseError(clone, res); });
    };
    /**
     * Request interceptor. Delays request if refresh is in progress
     * otherwise adds token to the headers
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     *
     * @returns {Observable}
     */
    AuthInterceptor.prototype.request = function (req) {
        if (this.refreshInProgress) {
            return this.delayRequest(req);
        }
        return this.addToken(req);
    };
    /**
     * Failed request interceptor, check if it has to be processed with refresh
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     * @param {HttpErrorResponse} res
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    AuthInterceptor.prototype.responseError = function (req, res) {
        var _this = this;
        var authService = this.injector.get(AUTH_SERVICE);
        var refreshShouldHappen = authService.refreshShouldHappen(res);
        if (refreshShouldHappen && !this.refreshInProgress) {
            this.refreshInProgress = true;
            authService
                .refreshToken()
                .subscribe(function () {
                _this.refreshInProgress = false;
                _this.refreshSubject.next(true);
            }, function () {
                _this.refreshInProgress = false;
                _this.refreshSubject.next(false);
            });
        }
        if (refreshShouldHappen && this.refreshInProgress) {
            return this.delayRequest(req, res);
        }
        return _throw._throw(res);
    };
    /**
     * Add access token to headers or the request
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    AuthInterceptor.prototype.addToken = function (req) {
        var authService = this.injector.get(AUTH_SERVICE);
        return first$2(map$2(authService.getAccessToken(), function (token) {
            if (token) {
                var headers = void 0;
                if (typeof authService.getHeaders === 'function') {
                    headers = authService.getHeaders(token);
                }
                else {
                    headers = { Authorization: "Bearer " + token };
                }
                return req.clone({
                    setHeaders: headers
                });
            }
            return req;
        }));
    };
    /**
     * Delay request, by subscribing on refresh event, once it finished, process it
     * otherwise throw error
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     * @param {HttpErrorResponse} [res]
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    AuthInterceptor.prototype.delayRequest = function (req, res) {
        var http$$1 = this.injector.get(http.HttpClient);
        return switchMap$2(first$2(this.refreshSubject), function (status) {
            if (status) {
                return http$$1.request(req);
            }
            return _throw._throw(res || req);
        });
    };
    return AuthInterceptor;
}());
exports.ɵa = __decorate$3([
    core.Injectable(),
    __metadata$2("design:paramtypes", [core.Injector])
], exports.ɵa);
var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
exports.AuthModule = (function () {
    function AuthModule() {
    }
    return AuthModule;
}());
exports.AuthModule = __decorate$2([
    core.NgModule({
        providers: [
            exports.PublicGuard,
            exports.ProtectedGuard,
            exports.ɵa,
            {
                provide: http.HTTP_INTERCEPTORS,
                useClass: exports.ɵa,
                multi: true,
            }
        ]
    })
], exports.AuthModule);

exports.AuthService = AuthService;
exports.AUTH_SERVICE = AUTH_SERVICE;
exports.PUBLIC_FALLBACK_PAGE_URI = PUBLIC_FALLBACK_PAGE_URI;
exports.PROTECTED_FALLBACK_PAGE_URI = PROTECTED_FALLBACK_PAGE_URI;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-auth.umd.js.map
