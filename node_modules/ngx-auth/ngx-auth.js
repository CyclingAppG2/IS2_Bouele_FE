import { Inject, Injectable, InjectionToken, Injector, NgModule } from '@angular/core';
import { Router } from '@angular/router';
import { first as first$1 } from 'rxjs/operator/first';
import { switchMap as switchMap$1 } from 'rxjs/operator/switchMap';
import { map as map$1 } from 'rxjs/operator/map';
import { _catch as _catch$1 } from 'rxjs/operator/catch';
import { _throw as _throw$1 } from 'rxjs/observable/throw';
import { HTTP_INTERCEPTORS, HttpClient } from '@angular/common/http';
import { Subject as Subject$1 } from 'rxjs/Subject';

/**
 * Essential service for authentication
 * @export
 * @interface AuthService
 */
class AuthService {
}

function first$2(obs) {
    return first$1.call(obs);
}
function switchMap$2(obs, project) {
    return switchMap$1.call(obs, project);
}
function map$2(obs, project) {
    return map$1.call(obs, project);
}
function _catch$2(obs, selector) {
    return _catch$1.call(obs, selector);
}

const AUTH_SERVICE = new InjectionToken('AUTH_SERVICE');
const PUBLIC_FALLBACK_PAGE_URI = new InjectionToken('PUBLIC_FALLBACK_PAGE_URI');
const PROTECTED_FALLBACK_PAGE_URI = new InjectionToken('PROTECTED_FALLBACK_PAGE_URI');

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 *
 * usage: { path: 'test', component: TestComponent, canActivate: [ PublicGuard ] }
 *
 * @export
 *
 * @class PublicGuard
 *
 * @implements {CanActivate}
 * @implements {CanActivateChild}
 */
let PublicGuard = class PublicGuard {
    constructor(authService, protectedFallbackPageUri, router$$1) {
        this.authService = authService;
        this.protectedFallbackPageUri = protectedFallbackPageUri;
        this.router = router$$1;
    }
    /**
     * CanActivate handler
     *
     * @param {ActivatedRouteSnapshot} _route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    canActivate(_route, state) {
        return map$2(this.authService.isAuthorized(), (isAuthorized) => {
            if (isAuthorized && !this.isProtectedPage(state)) {
                this.navigate(this.protectedFallbackPageUri);
                return false;
            }
            return true;
        });
    }
    /**
     * CanActivateChild handler
     *
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    canActivateChild(route, state) {
        return this.canActivate(route, state);
    }
    /**
     * Check, if current page is protected fallback page
     *
     * @private
     *
     * @param {RouterStateSnapshot} state
     *
     * @returns {boolean}
     */
    isProtectedPage(state) {
        return state.url === this.protectedFallbackPageUri;
    }
    /**
     * Navigate away from the app / path
     *
     * @private
     * @param {string} url
     */
    navigate(url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    }
};
PublicGuard = __decorate([
    Injectable(),
    __param(0, Inject(AUTH_SERVICE)),
    __param(1, Inject(PROTECTED_FALLBACK_PAGE_URI)),
    __metadata("design:paramtypes", [AuthService, String, Router])
], PublicGuard);

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Guard, checks access token availability and allows or disallows access to page,
 * and redirects out
 *
 * usage: { path: 'test', component: TestComponent, canActivate: [ AuthGuard ] }
 *
 * @export
 *
 * @class ProtectedGuard
 *
 * @implements {CanActivate}
 * @implements {CanActivateChild}
 */
let ProtectedGuard = class ProtectedGuard {
    constructor(authService, publicFallbackPageUri, router$$1) {
        this.authService = authService;
        this.publicFallbackPageUri = publicFallbackPageUri;
        this.router = router$$1;
    }
    /**
     * CanActivate handler
     *
     * @param {ActivatedRouteSnapshot} _route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    canActivate(_route, state) {
        return map$2(this.authService.isAuthorized(), (isAuthorized) => {
            if (!isAuthorized && !this.isPublicPage(state)) {
                this.navigate(this.publicFallbackPageUri);
                return false;
            }
            return true;
        });
    }
    /**
     * CanActivateChild handler
     *
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     *
     * @returns {Observable<boolean>}
     */
    canActivateChild(route, state) {
        return this.canActivate(route, state);
    }
    /**
     * Check, if current page is public fallback page
     *
     * @private
     *
     * @param {RouterStateSnapshot} state
     *
     * @returns {boolean}
     */
    isPublicPage(state) {
        return state.url === this.publicFallbackPageUri;
    }
    /**
     * Navigate away from the app / path
     *
     * @private
     * @param {string} url
     */
    navigate(url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            this.router.navigateByUrl(url);
        }
    }
};
ProtectedGuard = __decorate$1([
    Injectable(),
    __param$1(0, Inject(AUTH_SERVICE)),
    __param$1(1, Inject(PUBLIC_FALLBACK_PAGE_URI)),
    __metadata$1("design:paramtypes", [AuthService, String, Router])
], ProtectedGuard);

var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let AuthInterceptor = class AuthInterceptor {
    constructor(injector) {
        this.injector = injector;
        /**
         * Is refresh token is being executed
         *
         * @private
         *
         * @type {boolean}
         */
        this.refreshInProgress = false;
        /**
         * Notify all outstanding requests through this subject
         *
         * @private
         *
         * @type {Subject<boolean>}
         */
        this.refreshSubject = new Subject$1();
    }
    /**
     * Intercept an outgoing `HttpRequest`
     *
     * @param {HttpRequest<*>} req
     * @param {HttpHandler} delegate
     *
     * @returns {Observable<HttpEvent<*>>}
     */
    intercept(req, delegate) {
        const authService = this.injector.get(AUTH_SERVICE);
        if (authService.verifyTokenRequest(req.url)) {
            return delegate.handle(req);
        }
        return this.processIntercept(req, delegate);
    }
    /**
     * Process all the requests via custom interceptors.
     *
     * @private
     *
     * @param {HttpRequest<*>} original
     * @param {HttpHandler} delegate
     *
     * @returns {Observable<HttpEvent<*>>}
     */
    processIntercept(original, delegate) {
        const clone = original.clone();
        return _catch$2(switchMap$2(this.request(clone), (req) => delegate.handle(req)), (res) => this.responseError(clone, res));
    }
    /**
     * Request interceptor. Delays request if refresh is in progress
     * otherwise adds token to the headers
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     *
     * @returns {Observable}
     */
    request(req) {
        if (this.refreshInProgress) {
            return this.delayRequest(req);
        }
        return this.addToken(req);
    }
    /**
     * Failed request interceptor, check if it has to be processed with refresh
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     * @param {HttpErrorResponse} res
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    responseError(req, res) {
        const authService = this.injector.get(AUTH_SERVICE);
        const refreshShouldHappen = authService.refreshShouldHappen(res);
        if (refreshShouldHappen && !this.refreshInProgress) {
            this.refreshInProgress = true;
            authService
                .refreshToken()
                .subscribe(() => {
                this.refreshInProgress = false;
                this.refreshSubject.next(true);
            }, () => {
                this.refreshInProgress = false;
                this.refreshSubject.next(false);
            });
        }
        if (refreshShouldHappen && this.refreshInProgress) {
            return this.delayRequest(req, res);
        }
        return _throw$1(res);
    }
    /**
     * Add access token to headers or the request
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    addToken(req) {
        const authService = this.injector.get(AUTH_SERVICE);
        return first$2(map$2(authService.getAccessToken(), (token) => {
            if (token) {
                let headers;
                if (typeof authService.getHeaders === 'function') {
                    headers = authService.getHeaders(token);
                }
                else {
                    headers = { Authorization: `Bearer ${token}` };
                }
                return req.clone({
                    setHeaders: headers
                });
            }
            return req;
        }));
    }
    /**
     * Delay request, by subscribing on refresh event, once it finished, process it
     * otherwise throw error
     *
     * @private
     *
     * @param {HttpRequest<*>} req
     * @param {HttpErrorResponse} [res]
     *
     * @returns {Observable<HttpRequest<*>>}
     */
    delayRequest(req, res) {
        const http$$1 = this.injector.get(HttpClient);
        return switchMap$2(first$2(this.refreshSubject), (status) => {
            if (status) {
                return http$$1.request(req);
            }
            return _throw$1(res || req);
        });
    }
};
AuthInterceptor = __decorate$3([
    Injectable(),
    __metadata$2("design:paramtypes", [Injector])
], AuthInterceptor);

var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let AuthModule = class AuthModule {
};
AuthModule = __decorate$2([
    NgModule({
        providers: [
            PublicGuard,
            ProtectedGuard,
            AuthInterceptor,
            {
                provide: HTTP_INTERCEPTORS,
                useClass: AuthInterceptor,
                multi: true,
            }
        ]
    })
], AuthModule);

/**
 * Generated bundle index. Do not edit.
 */

export { AuthInterceptor as ɵa, AuthService, PublicGuard, ProtectedGuard, AUTH_SERVICE, PUBLIC_FALLBACK_PAGE_URI, PROTECTED_FALLBACK_PAGE_URI, AuthModule };
//# sourceMappingURL=ngx-auth.js.map
